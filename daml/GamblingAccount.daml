module GamblingAccount where

import Daml.Script
import DA.Action
import DA.Foldable (forA_)
import Asset

-- This function validates whether the list of input assets can be merged and then split for use in
-- the Merge_Split and Create_Transfer choices of GamblingAccount template
-- If the assets can be merged and the total amount is sufficient to split it into outputAmounts, then
-- the function returns the total amount of input assets. Otherwise the action fails.
validateTxInputs: [ContractId Asset] -> ContractId GamblingAccount -> Decimal -> Update Decimal
validateTxInputs assetCids accountCid outputAmount = do
  account <- fetch accountCid
  totAssetAmount <- sum <$> forA assetCids \assetCid -> do
    asset <- fetch assetCid
    assertMsg "Issuer mismatch between asset and account" $
      asset.assetType == account.assetType
    assertMsg "Owner mismatch between asset and account" $
      asset.owner == account.owner
    return asset.amount
  assertMsg "Insufficient funds passed to create all output assets" $
    totAssetAmount >= outputAmount
  return totAssetAmount

template GamblingAccount
  with
    assetType : AssetType
    bookie : Party
    owner : Party
  where
      signatory assetType.issuer, owner
      observer bookie
      ensure assetType.issuer /= bookie 
      -- CONSIDERATION: issuer cannot be a bookie because then they 
      -- could issue themselves unlimited funds to eventually beat out all bettora
      key (assetType, bookie, owner) : (AssetType, Party, Party)
      maintainer key._3
      -- CONSIDERATION: we made it so that a bettor
      -- can only have one GamblingAccount contract for a particular currency with a particular bookie
      -- so that each GamblingAccount contract can be uniquely identified by the key above
      -- TODO: add ensure statement to ensure bettor does not already have a GamblingAccount contract 
      -- with the issuer and bookie

      nonconsuming choice Invite_New_Owner : ContractId GamblingAccountProposal
        with
          newBettor : Party
        controller bookie
        do 
          create GamblingAccountProposal with
            gamblingAccount = this
            newBettor

      -- This choice consolidates the input set of assets in the account and from the total amount
      -- creates new set of Asset contracts in the desired input amounts plus one more Asset with the remaining amount
      -- The purpose is to create Asset contracts in desired denomination from the list of assets in the account
      nonconsuming choice Merge_Split : [ContractId Asset]
        with
          -- The list of assets to consolidate
          assetCids : [ContractId Asset]
          -- The desired amounts of the output assets
          outputAmounts : [Decimal]
        controller owner
        do
          totAssetAmount <- validateTxInputs assetCids self $ sum outputAmounts
          forA_ assetCids archive
          let
            createOutputAssets assetsList amt = do
              assertMsg "Each output asset amount must be positive" $
                amt > 0.0
              a <- create Asset with
                assetType
                owner
                amount = amt
              return $ a :: assetsList
          outputAssetCids <- foldlA createOutputAssets [] outputAmounts
          if (totAssetAmount > sum outputAmounts)
          then do 
            a <- create Asset with
              assetType
              owner
              amount = (totAssetAmount - sum outputAmounts)
            return $ a :: outputAssetCids
          else
            return outputAssetCids

      -- CONSIDERATION: for simplicity's sake we made it so that a GamblingAccount owner 
      -- could only create one transfer at a time
      nonconsuming choice Create_Transfer : ()
        with 
          assetCids : [ContractId Asset]
          recipient : Party
          amount : Decimal
        controller owner
        do
          totAssetAmount <- validateTxInputs assetCids self amount
          forA_ assetCids archive
          create AssetTransfer with
            asset = Asset with
              assetType
              owner
              amount
            recipient
          when (totAssetAmount > amount) do
            create Asset with
              assetType
              owner
              amount = totAssetAmount - amount
            return()

      -- The purpose of this choice is to obtain issuer's authority required to accept the transfer.
      -- This construct ensures that transfers cannot be made to a party without a GamblingAccount corresponding to the asset
      nonconsuming choice Deposit_Transfer_Into_Account : ContractId Asset
        with
          transferCid : ContractId AssetTransfer
        controller owner 
        do
          transfer <- fetch transferCid
          assertMsg "Issuer mismatch between transfer asset and account" $
            transfer.asset.assetType == assetType
          assertMsg "Mismatch between account owner and transfer recipient" $
            transfer.recipient == owner
          exercise transferCid Accept_Transfer

template GamblingAccountProposal
  with
    gamblingAccount : GamblingAccount
    newBettor : Party
  where
    signatory gamblingAccount.assetType.issuer
    observer newBettor

    choice AcceptGamblingAccountProposal : ContractId GamblingAccount
      controller newBettor
      do  
        create gamblingAccount with
          owner = newBettor

setup : Script ()
setup = script do
-- user_setup_begin
  alice <- allocatePartyWithHint "Alice" (PartyIdHint "Alice")
  bob   <- allocatePartyWithHint "Bob" (PartyIdHint "Bob")
  charlie   <- allocatePartyWithHint "Charlie" (PartyIdHint "Charlie")
  gambleunion <- allocatePartyWithHint "GambleUnion" (PartyIdHint "GambleUnion")
  gambleking <- allocatePartyWithHint "GambleKing" (PartyIdHint "GambleKing")
  aliceId <- validateUserId "alice"
  bobId <- validateUserId "bob"
  charlieId <- validateUserId "charlie"
  gambleunionId <- validateUserId "gambleunion"
  gamblekingId <- validateUserId "gambleking"
-- user_setup_end

  let
    gamble_tkn = AssetType with
      issuer = gambleunion
      symbol = "GBL"

  asset1Cid <- submit gambleunion do 
    createCmd Asset with
      assetType = gamble_tkn
      owner = gambleunion
      amount = 10.0

  



  pure()