module Match where

import Daml.Script
import DA.Foldable (forA_)
import DA.List
import DA.Optional
import DA.Assert
import Account
import Asset

makeTextOptional: Text -> Optional Text
makeTextOptional text = if (True) then Some text else None

makeTransferOptional: ContractId AssetTransfer -> Optional (ContractId AssetTransfer)
makeTransferOptional transfer = if (True) then Some transfer else None

template Match
  with
    admin       : Party
    gamblersUnion : GamblersUnion
    competitors : (Text, Text)
    time        : Time
    winner : Optional Text
  where
    signatory admin
    observer gamblersUnion.registeredBookies, gamblersUnion.assetType.issuer
    -- admin, competitors, time identifies a unique Match, and we will 
    -- enforce that the bookie can only create one BetSlip per Match
    key (admin, competitors, time) : (Party, (Text, Text), Time)
    maintainer key._1

    nonconsuming choice CreateBetSlip : ContractId BetSlip
      with
        odds : [(Text, Decimal, Decimal)]
        bookie : Party
      controller bookie
      do
        (houseContractId, housePayload) <- fetchByKey @House (bookie, gamblersUnion.assetType) 
        let bettors = housePayload.registeredBettors
        create BetSlip with
         admin = admin
         bookie = bookie 
         competitors = competitors
         odds = odds
         time = time        
         bettors=bettors
         gamblersUnion = gamblersUnion
         betCids = []          

    choice SettleMatch : ContractId Match
      with
        victor : Text
      controller admin
      do
        create this with
          winner = makeTextOptional victor
        -- forA_ gamblersUnion.registeredBookies (\bookie -> do
        --   (betSlipContractID, betSlipPayload) <- fetchByKey @BetSlip (bookie, admin, competitors, time)
        --   exercise betSlipContractID (SettleBets victor)
        --   )

template BetSlip
  with
    admin         : Party
    bookie        : Party
    competitors   : (Text, Text)
    odds          : [(Text,Decimal,Decimal)]      -- Tuple like Thunder, 3, 1 odds. 
                                          -- First int in odds represents bettor's profit if they win, 
                                          -- second int represents how much they bet. For example, if the odds are 3:1,
                                          -- the bettor would bet $1 to win $3 profit, meaning they would win $4 total.
    time          : Time
    bettors       : [Party]
    gamblersUnion : GamblersUnion
    betCids : [ContractId Bet]                  
  where
    signatory bookie
    observer bettors, admin, gamblersUnion.assetType.issuer
    key (bookie, admin, competitors, time) : (Party, Party, (Text, Text), Time)
    maintainer key._1
    
    nonconsuming choice Create_Bet_Proposal : ContractId BetProposal
      with
        bettor1Odds : [(Text,Decimal,Decimal)]
        bettor1 : Party 
        bettor2 : Party 
        bettor1Amount : Decimal
        bettor1Pick : Text
        bettor1AssetCids: [ContractId Asset]
      controller bettor1     
      do
        (bettor1GamblingAcctCid, bettor1GamblingAcct) <- fetchByKey @GamblingAccount (gamblersUnion.assetType, bookie, bettor1)
        
        if (bettor2 == bookie) then do 
          assertMsg "bettor1 cannot provide odds if placing a bet against bookie, they must accept bookie's odds" (null bettor1Odds)
        
          -- create transfer from bettor1 to bettor2
          bettor1TransferCid <- exercise bettor1GamblingAcctCid Create_Transfer with 
            assetCids = bettor1AssetCids 
            transfer = (bettor1Amount, bettor2)
            
          create BetProposal with
            betAgreement = BetAgreement with
              odds
              bettor1
              bettor2
              bookie
              bettor1Amount
              bettor1Pick
              bettor1AssetCids
              bettor2AssetCids = []
              bettor1TransferCid
              bettor2TransferCid = None
              gamblersUnion
              matchAdmin = admin
              competitors
              time
        else do 
          assertMsg "bettor1 must provide odds if placing a bet against another bettor" (not (null bettor1Odds))
          -- split bettor1 assets into one asset for transfer to bettor2 and another asset
          -- for transfer to bookie to pay house fee
          bettor1NewAssetCids <- exercise bettor1GamblingAcctCid Merge_Split with 
            assetCids = bettor1AssetCids 
            outputAmounts = [0.95 * bettor1Amount, 0.05 * bettor1Amount]

          -- create transfer from bettor1 to bettor2 with house fee deducted
          bettor1TransferCid <- exercise bettor1GamblingAcctCid Create_Transfer with
            assetCids = [last bettor1NewAssetCids]
            transfer = (0.95 * bettor1Amount, bettor2)

          -- create transfer from bettor1 to bookie to pay house fee
          bettor1HouseTransferCid <- exercise bettor1GamblingAcctCid Create_Transfer with 
            assetCids = [bettor1NewAssetCids!!1]
            transfer = (0.05 * bettor1Amount, bookie)
          
          create BetProposal with
            betAgreement = BetAgreement with
              odds = bettor1Odds
              bettor1
              bettor2
              bookie
              bettor1Amount
              bettor1Pick
              bettor1AssetCids
              bettor2AssetCids = []
              bettor1TransferCid
              bettor2TransferCid = None
              gamblersUnion
              matchAdmin = admin
              competitors
              time

    choice SettleBets: ()
      controller gamblersUnion.assetType.issuer
      do 
        forA_ betCids (\betCid -> do
            exercise betCid Settle_Bet
          )
        pure()

template Bet
  with
    odds : [(Text,Decimal,Decimal)]
    bettor1 : Party
    bettor2 : Party
    bookie : Party
    bettor1Amount : Decimal
    bettor1Pick : Text
    bettor1AssetCids : [ContractId Asset]
    bettor2AssetCids : [ContractId Asset]
    bettor1TransferCid : ContractId AssetTransfer
    bettor2TransferCid : Optional (ContractId AssetTransfer)
    gamblersUnion : GamblersUnion
    matchAdmin : Party
    competitors : (Text, Text)
    time : Time
  where
    signatory bettor1, bettor2, bookie
    observer gamblersUnion.assetType.issuer

    choice Settle_Bet : ()
      controller gamblersUnion.assetType.issuer
      do
        (matchCid, match) <- fetchByKey @Match (matchAdmin, competitors, time)
        assertMsg "Cannot settle a bet before match winner is declared" (isSome match.winner)

        if (match.winner == makeTextOptional bettor1Pick) then do 
          -- accept bettor2 transfer
          exercise (fromSome bettor2TransferCid) Accept_Transfer
          -- cancel bettor1 transfer
          exercise bettor1TransferCid Reject_Transfer
          pure()
        else do
          -- accept bettor1 transfer
          exercise bettor1TransferCid Accept_Transfer
          -- cancel bettor2 transfer
          exercise (fromSome bettor2TransferCid) Reject_Transfer
          pure()

template BetProposal
  with
    betAgreement : BetAgreement
  where
    signatory betAgreement.bettor1
    observer betAgreement.bookie, betAgreement.bettor2

    choice AcceptBetProposal : ContractId BetAgreement
      with
        bettor2AssetCids : [ContractId Asset]
      controller betAgreement.bettor2
      do 
        (bettor2GamblingAcctCid, bettor2GamblingAcct) <- fetchByKey @GamblingAccount (betAgreement.gamblersUnion.assetType, betAgreement.bookie, betAgreement.bettor2)
        let competitorIndex = fromSome (findIndex (\competitorOdds -> competitorOdds._1 == betAgreement.bettor1Pick) betAgreement.odds)
        let bettor2Amount = ((betAgreement.odds!!competitorIndex)._2 / (betAgreement.odds!!competitorIndex)._3) * betAgreement.bettor1Amount + betAgreement.bettor1Amount

        if (betAgreement.bettor2 == betAgreement.bookie) then do
          -- create transfer from bettor2 to bettor1
          bettor2TransferCid <- exercise bettor2GamblingAcctCid Create_Transfer with 
            assetCids = bettor2AssetCids 
            transfer = (bettor2Amount, betAgreement.bettor1)

          create betAgreement with
            bettor2AssetCids
            bettor2TransferCid = makeTransferOptional bettor2TransferCid
        else do
          -- split bettor2 assets into one asset for transfer to bettor1 and another asset
          -- for transfer to bookie to pay house fee
          bettor2NewAssetCids <- exercise bettor2GamblingAcctCid Merge_Split with 
            assetCids = bettor2AssetCids 
            outputAmounts = [0.95 * bettor2Amount, 0.05 * bettor2Amount]
          
          -- create transfer from bettor2 to bettor1
          bettor2TransferCid <- exercise bettor2GamblingAcctCid Create_Transfer with 
            assetCids = [last bettor2NewAssetCids]
            transfer = (0.95 * bettor2Amount, betAgreement.bettor1)

          -- create transfer from bettor2 to bookie to pay house fee
          bettor2HouseTransferCid <- exercise bettor2GamblingAcctCid Create_Transfer with 
            assetCids = [bettor2NewAssetCids!!1]
            transfer = (0.05 * bettor2Amount, betAgreement.bookie)

          create betAgreement with
            bettor2AssetCids
            bettor2TransferCid = makeTransferOptional bettor2TransferCid


template BetAgreement
  with
    odds : [(Text,Decimal,Decimal)]
    bettor1 : Party
    bettor2 : Party
    bookie : Party
    bettor1Amount : Decimal
    bettor1Pick : Text
    bettor1AssetCids : [ContractId Asset]
    bettor2AssetCids : [ContractId Asset]
    bettor1TransferCid : ContractId AssetTransfer
    bettor2TransferCid : Optional (ContractId AssetTransfer)
    gamblersUnion : GamblersUnion
    matchAdmin : Party
    competitors : (Text, Text)
    time : Time
  where
    signatory bettor1, bettor2
    observer bookie

    choice Create_Bet : ContractId Bet
      controller bookie
      do
        -- create bet
        newBetCid <- create Bet with
          odds
          bettor1
          bettor2
          bookie
          bettor1Amount
          bettor1Pick
          bettor1AssetCids
          bettor2AssetCids
          bettor1TransferCid
          bettor2TransferCid
          gamblersUnion
          matchAdmin
          competitors
          time

        -- archive and recreate BetSlip with new betCid added to BetSlip's list of betCids
        (betSlipCid, betSlip) <- fetchByKey @BetSlip (bookie, matchAdmin, competitors, time)
        let oldBetSlipCids = betSlip.betCids
        archive betSlipCid
        create betSlip with
          betCids = newBetCid :: oldBetSlipCids

        return newBetCid

setup : Script() 
setup = script do
-- user_setup_begin
  alice    <- allocatePartyWithHint "Alice" (PartyIdHint "Alice")
  bob      <- allocatePartyWithHint "Bob" (PartyIdHint "Bob")
  charlie  <- allocatePartyWithHint "Charlie" (PartyIdHint "Charlie")
  gambleunion <- allocatePartyWithHint "GambleUnion" (PartyIdHint "GambleUnion")
  matchqueen <- allocatePartyWithHint "MatchQueen" (PartyIdHint "MatchQueen")
  gambleking <- allocatePartyWithHint "GambleKing" (PartyIdHint "GambleKing")
  aliceId <- validateUserId "alice"
  bobId   <- validateUserId "bob"
  charlieId <- validateUserId "charlie"
  gambleunionId <- validateUserId "gambleunion"
  matchqueenId <- validateUserId "matchqueen"
  gamblekingId <- validateUserId "gambleking"
  
-- user_setup_end
  let bettors = [alice,bob]
      odds = [ ("Thunder",3,2), ("QuickSand",2,1)]

  currentTime <- getTime -- using getTime to get a valid UTC timestamp
                          -- but we should really set time of matches to be an arbitrary timestamp in the future
  
  let bettors = [alice, bob]

  let
    gamble_tkn = AssetType with
      issuer = gambleunion
      symbol = "GBL"

  -- create union
  gamblersUnion1Cid <- submit gambleunion do
    createCmd GamblersUnion with
      assetType = gamble_tkn
      registeredBookies = []

  -- create house
  houseProposal1 <- submit gambleunion do
    exerciseCmd gamblersUnion1Cid (Create_House_Proposal gambleking)

  houseAgreement1 <- submit gambleking do 
    exerciseCmd houseProposal1 HouseProposal_Accept

  house1Cid <- submit gambleunion do
    exerciseCmd houseAgreement1 Create_House

  gamblekingAcctTuple <- queryContractKey @GamblingAccount gambleking (gamble_tkn, gambleking, gambleking)
  let (gamblekingAcctCid, gamblekingAcct) = fromSome gamblekingAcctTuple

  -- create alice account
  aliceAcctProposalCid <- submit gambleking do
    exerciseCmd gamblekingAcctCid (Invite_New_Owner alice)

  aliceAcctAgreementCid <- submit alice do
    exerciseCmd aliceAcctProposalCid AcceptGamblingAccountProposal

  aliceAcctCid <- submit gambleunion do
    exerciseCmd aliceAcctAgreementCid Create_Gambling_Account

  -- create bob account
  bobAcctProposalCid <- submit gambleking do
    exerciseCmd gamblekingAcctCid (Invite_New_Owner bob)

  bobAcctAgreementCid <- submit bob do
    exerciseCmd bobAcctProposalCid AcceptGamblingAccountProposal

  bobAcctCid <- submit gambleunion do
    exerciseCmd bobAcctAgreementCid Create_Gambling_Account

  -- create assets
  asset1Cid <- submit gambleunion do
    createCmd Asset with
      assetType = gamble_tkn
      owner = gambleunion
      amount = 100.0

  asset2Cid <- submit gambleunion do
    createCmd Asset with
      assetType = gamble_tkn
      owner = gambleunion
      amount = 200.0

  asset3Cid <- submit gambleunion do
    createCmd Asset with
      assetType = gamble_tkn
      owner = gambleunion
      amount = 300.0

  -- get accounts
  gambleunionAcctTuple <- queryContractKey @GamblingAccount gambleunion (gamble_tkn, gambleking, gambleunion)
  let (gambleunionAcctCid, gambleunionAcct) = fromSome gambleunionAcctTuple

  -- test negative transfer
  submitMustFail gambleunion do
    exerciseCmd gambleunionAcctCid Merge_Split with
      assetCids = [asset1Cid, asset2Cid, asset3Cid] 
      outputAmounts = [-400.0, 150.0]

  -- break assets into different denominations
  newAssetCids <- submit gambleunion do
    exerciseCmd gambleunionAcctCid Merge_Split with
      assetCids = [asset1Cid, asset2Cid, asset3Cid] 
      outputAmounts = [400.0, 150.0]

  -- create asset transfers
  submit gambleunion do 
    exerciseCmd gambleunionAcctCid Create_Transfers with
      assetCids = newAssetCids
      transfers = [(170.0, alice), (130.0, bob), (200.0, gambleking)]
  
  -- get all asset transfers being received by a particular party
  aliceTransfers <- queryFilter @AssetTransfer alice (\tx -> tx.recipient==alice)
  let aliceTransferCid = (head aliceTransfers)._1

  bobTransfers <- queryFilter @AssetTransfer bob (\tx -> tx.recipient==bob)
  let bobTransferCid = (head bobTransfers)._1

  bookieTransfers <- queryFilter @AssetTransfer gambleking (\tx -> tx.recipient==gambleking)
  let bookieTransferCid = (head bookieTransfers)._1

  -- Cannot accept via Accept_transfer
    -- Asset issuer or owner cannot accept transfer by calling Accept_Transfer choice on Asset contract
  submitMustFail alice do
    exerciseCmd aliceTransferCid Accept_Transfer
  
  -- Ownership transfer via Deposit_Transfer_Into_Account
  forA_ aliceTransfers (\transferCid -> do
    submit alice do
      exerciseCmd aliceAcctCid Deposit_Transfer_Into_Account with 
        transferCid = transferCid._1
    )

  submit bob do
    exerciseCmd bobAcctCid Deposit_Transfer_Into_Account with 
      transferCid = bobTransferCid

  submit gambleking do
    exerciseCmd gamblekingAcctCid Deposit_Transfer_Into_Account with 
      transferCid = bookieTransferCid

  gamblersUnionTuple <- queryContractKey @GamblersUnion gambleunion gamble_tkn
  let gamblersUnion = (fromSome gamblersUnionTuple)._2

  -- create Match and BetSlip
  match1Cid <- submit matchqueen do
    createCmd Match with
      admin = matchqueen
      gamblersUnion  = gamblersUnion
      competitors = ("Vikings", "Eagles")
      time = currentTime
      winner = None

  betSlip1Cid <- submit gambleking do
    exerciseCmd match1Cid CreateBetSlip with
      odds = [("Vikings", 3.0, 1.0), ("Eagles", 1.0, 3.0)]
      bookie = gambleking

  -- get all active asset contracts for a particular party
  aliceAssetTuples <- queryFilter @Asset alice (\asset -> asset.owner==alice)
  let aliceAssetCids = (unzip aliceAssetTuples)._1

  bobAssetTuples <- queryFilter @Asset bob (\asset -> asset.owner==bob)
  let bobAssetCids = (unzip bobAssetTuples)._1

  bookieAssetTuples <- queryFilter @Asset gambleking (\asset -> asset.owner==gambleking)
  let bookieAssetCids = (unzip bookieAssetTuples)._1

  -- create bet against bookie
  betProposal1 <- submit alice do
    exerciseCmd betSlip1Cid Create_Bet_Proposal with
      bettor1Odds = []
      bettor1 = alice
      bettor2 = gambleking
      bettor1Amount = 10.0
      bettor1Pick = "Eagles"
      bettor1AssetCids = aliceAssetCids

  betAgreement1 <- submit gambleking do
    exerciseCmd betProposal1 AcceptBetProposal with
      bettor2AssetCids = bookieAssetCids

  bet1Cid <- submit gambleking do
    exerciseCmd betAgreement1 Create_Bet

  -- create bet against other bettor
  betSlip2Tuple <- queryContractKey @BetSlip gambleking (gambleking, matchqueen, ("Vikings", "Eagles"), currentTime)
  let betSlipCid2 = (fromSome betSlip2Tuple)._1

  betProposal2Cid <- submit bob do
    exerciseCmd betSlipCid2 Create_Bet_Proposal with
      bettor1Odds = [("Vikings", 2.0, 1.0), ("Eagles", 1.0, 2.0)]
      bettor1 = bob
      bettor2 = alice
      bettor1Amount = 10.0
      bettor1Pick = "Eagles"
      bettor1AssetCids = bobAssetCids

  aliceAssetTuples2 <- queryFilter @Asset alice (\asset -> asset.owner==alice)
  let aliceAssetCids2 = (unzip aliceAssetTuples2)._1

  betAgreement2Cid <- submit alice do
    exerciseCmd betProposal2Cid AcceptBetProposal with
      bettor2AssetCids = aliceAssetCids2

  bet2Cid <- submit gambleking do
    exerciseCmd betAgreement2Cid Create_Bet

  -- settle match
  submit matchqueen do
    exerciseCmd match1Cid (SettleMatch "Vikings")

  -- settle bets
  
  -- submit gambleunion do
  --   exerciseCmd bet1Cid Settle_Bet

  -- submit gambleunion do
  --   exerciseCmd bet2Cid Settle_Bet

  newBetSlipTuple <- queryContractKey @BetSlip gambleunion (gambleking, matchqueen, ("Vikings", "Eagles"), currentTime)
  let newBetSlipCid = (fromSome newBetSlipTuple)._1

  submit gambleunion do
    exerciseCmd newBetSlipCid SettleBets

  -- Deposit House Fees into bookie gambling acct

  bookieHouseTuple <- queryContractKey @House gambleking (gambleking, gamble_tkn)
  let bookieHouseCid = (fromSome bookieHouseTuple)._1

  bookieTransferTuples <- queryFilter @AssetTransfer gambleking (\transfer -> transfer.recipient==gambleking)
  let bookieTransferCids = (unzip bookieTransferTuples)._1

  submit gambleking do
    exerciseCmd bookieHouseCid Deposit_House_Fees with
      transferCids = bookieTransferCids

  -- Assert balance
  -- optionalAccount <- queryContractId gambleunion gambleunionAcctCid
  -- let account = fromSome optionalAccount
  -- balance <- accountBalance account
  -- debug balance
  -- balance === 240.0

  pure()