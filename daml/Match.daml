module Match where

import Daml.Script
import DA.Foldable (forA_)
import DA.List
import DA.Optional
import Account
import Asset
import Bet

-- TODO: Include comment to explain templates below for those who are not up to date on the code

template Match
  with
    admin       : Party
    gamblersUnion : GamblersUnion
    competitors : [Text]
    time        : Time
  where
    signatory admin
    observer gamblersUnion.registeredBookies
    -- admin, competitors, time identifies a unique Match, and we will 
    -- enforce that the bookie can only create one BetSlip per Match
    key (admin, competitors, time) : (Party, [Text], Time)
    maintainer key._1

    nonconsuming choice CreateBetSlip : ContractId BetSlip
      with
        odds : [(Text, Decimal, Decimal)]
        bookie : Party
      controller bookie
      do
        (houseContractId, housePayload) <- fetchByKey @House (bookie, gamblersUnion.assetType) 
        let bettors = housePayload.registeredBettors
        create BetSlip with
         admin = admin
         bookie = bookie 
         competitors = competitors
         odds = odds
         time = time        
         bettors=bettors
         gamblersUnion = gamblersUnion          

    choice SettleMatch : ()
      with
        victor : Text
      controller admin
      do
        forA_ gamblersUnion.registeredBookies (\bookie -> do
          (betSlipContractID, betSlipPayload) <- fetchByKey @BetSlip (bookie, competitors, time)
          exercise betSlipContractID SettleBets
          )

template BetSlip
  with
    admin         : Party
    bookie        : Party
    competitors   : [Text]
    odds          : [(Text,Decimal,Decimal)]      -- Tuple like Thunder, 3, 1 odds. 
                                          -- First int in odds represents bettor's profit if they win, 
                                          -- second int represents how much they bet. For example, if the odds are 3:1,
                                          -- the bettor would bet $1 to win $3 profit, meaning they would win $4 total.
    time          : Time
    bettors       : [Party]
    gamblersUnion : GamblersUnion                  
  where
    signatory bookie
    observer bettors, admin -- Ask how we can allow bettors to exercise choices 
                      -- on this contract without seeing each other as bettors
    key (bookie, competitors, time) : (Party, [Text], Time)
    maintainer key._1
    
    nonconsuming choice PlaceBet : ContractId Bet
      with
        betAmount : Decimal
        horsePick : Text
        bettor: Party
        bettorAssetCids: [ContractId Asset]
        bookieAssetCids: [ContractId Asset]
      controller bettor     
      do 
        -- create two transfers 
        (bettorGamblingAcctCid, bettorGamblingAcct) <- fetchByKey @GamblingAccount (gamblersUnion.assetType, bookie, bettor)
        (bookieGamblingAcctCid, bookieGamblingAcct) <- fetchByKey @GamblingAccount (gamblersUnion.assetType, bookie, bookie)

        exercise bettorGamblingAcctCid Create_Transfers with 
          assetCids = bettorAssetCids 
          transfers = [(betAmount, bookie)]

        let competitorIndex = fromSome (findIndex (\competitorOdds -> competitorOdds._1 == horsePick) odds)
        let bookieBetAmount = (odds!!competitorIndex)._2 * betAmount + betAmount
        exercise bookieGamblingAcctCid Create_Transfers with 
          assetCids = bookieAssetCids 
          transfers = [(bookieBetAmount, bettor)]

        create Bet with
           bookie    = bookie
           bettor    = bettor
           pick      = horsePick
           amount    = betAmount
                      
    choice SettleBets: ()  
      with 
      controller admin
      do 
        -- ensure all bet contracts get archived
       return ()


setup : Script() 
setup = script do
-- user_setup_begin
  alice    <- allocatePartyWithHint "Alice" (PartyIdHint "Alice")
  bob      <- allocatePartyWithHint "Bob" (PartyIdHint "Bob")
  charlie  <- allocatePartyWithHint "Charlie" (PartyIdHint "Charlie")
  matchqueen <- allocatePartyWithHint "MatchQueen" (PartyIdHint "MatchQueen")
  gambleking <- allocatePartyWithHint "GambleKing" (PartyIdHint "GambleKing")
  aliceId <- validateUserId "alice"
  bobId   <- validateUserId "bob"
  charlieId <- validateUserId "charlie"
  matchqueenId <- validateUserId "matchqueen"
  gamblekingId <- validateUserId "gambleking"
  
-- user_setup_end
  let bettors = [alice,bob]
      odds = [ ("Thunder",3,2), ("QuickSand",2,1)]

  currentTime <- getTime -- using getTime to get a valid UTC timestamp
                          -- but we should really set time of matches to be an arbitrary timestamp in the future

  -- house1 <- submit gambleking do
  --   createCmd House with
  --     bookie = gambleking
  --     registeredBettors = bettors

  -- match1 <- submit matchqueen do
  --   createCmd Match with
  --     admin = matchqueen
  --     bookie = gambleking
  --     competitors = ["Thunder", "Quicksand"]
  --     time = currentTime
  
  -- firstSlip <-submit gambleking do
  --   exerciseCmd match1 CreateBetSlip with 
  --     odds = [ ("Thunder",3,2), ("QuickSand",2,1)]

  -- --  Happy Path 

  -- submit alice do
  --   exerciseCmd firstSlip PlaceBet with 
  --     betAmount = 152.00
  --     horsePick = "Thunder"
  --     bettor    =  alice  

  -- -- Unhappy path with authorization

  -- submitMustFail bob do
  --   exerciseCmd firstSlip PlaceBet with 
  --     betAmount = 162.00
  --     horsePick = "Thunder"
  --     bettor    = alice   

  -- submit matchqueen do
  --   exerciseCmd match1 SettleMatch with
  --     victor = "Thunder"

  pure()

  
  





