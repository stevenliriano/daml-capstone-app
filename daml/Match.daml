module Match where

import Daml.Script
import Bet
import House

template Match
  with
    admin       : Party
    bookie      : Party
    competitors : [Text]
    time        : Time
  where
    signatory admin
    observer bookie
    key (admin, time) : (Party, Time)
    maintainer key._1

    nonconsuming choice CreateBetSlip : ContractId BetSlip
      with
        odds : [(Text, Int, Int)]
      controller bookie
      do
        -- believe the BetSlip contract should be updated to only contain the fields below
        (houseContractId, housePayload) <- fetchByKey @House bookie 
        (matchContractID, matchPayload) <- fetchByKey @Match (admin, time) -- find more elegant way of getting contractID from within template
        let bettors = housePayload.registeredBettors
        create BetSlip with
         bookie = bookie 
         odds = odds        
         bettors=bettors
         matchCID = matchContractID
          

    -- choice SettleMatch : Text
    --   with
    --     victor : Text
    --   controller admin
    --   do
    --     assert "Match admin declared a victor that was not a competitor" $ (elemIndex victor competitors) !== None
    --     return victor

template BetSlip
  with
    bookie        : Party
    odds          : [(Text,Int,Int)]      -- Tuple like Thunder, 3, 1 odds
    bettors       : [Party]
    matchCID      : ContractId Match                     
  where
    signatory bookie
    observer bettors 
    
    nonconsuming choice PlaceBet : ContractId Bet
      with
        betAmount : Decimal
        horsePick : Text
        bettor: Party
      controller bettor                   -- potential question to DAML? 
      do create Bet with
           bookie    = bookie
           bettor    = bettor
           pick      = horsePick
           amount    = betAmount
           
    choice SettleBets: ()  
      with 
       
      controller bookie
      do 
       return ()


setup : Script() 
setup = script do
-- user_setup_begin
  alice    <- allocatePartyWithHint "Alice" (PartyIdHint "Alice")
  bob      <- allocatePartyWithHint "Bob" (PartyIdHint "Bob")
  charlie  <- allocatePartyWithHint "Charlie" (PartyIdHint "Charlie")
  matchqueen <- allocatePartyWithHint "MatchQueen" (PartyIdHint "MatchQueen")
  gambleking <- allocatePartyWithHint "GambleKing" (PartyIdHint "GambleKing")
  aliceId <- validateUserId "alice"
  bobId   <- validateUserId "bob"
  charlieId <- validateUserId "charlie"
  matchqueenId <- validateUserId "matchqueen"
  gamblekingId <- validateUserId "gambleking"
  
-- user_setup_end
  let bettors = [alice,bob]
      odds = [ ("Thunder",3,2), ("QuickSand",2,1)]

  currentTime <- getTime

  house1 <- submit gambleking do
    createCmd House with
      bookie = gambleking
      registeredBettors = bettors

  match1 <- submit matchqueen do
    createCmd Match with
      admin = matchqueen
      bookie = gambleking
      competitors = ["Thunder", "Quicksand"]
      time = currentTime
  
  submit gambleking do
    exerciseCmd match1 CreateBetSlip with 
      odds = odds

  -- BetSlip Test Script below ---------------------
  firstSlip <- submit gambleking do
    createCmd BetSlip with
      bookie  = gambleking
      odds  = odds
      bettors = bettors
      matchCID = match1

  --  Happy Path 

  submit alice do
    exerciseCmd firstSlip PlaceBet with 
      betAmount = 152.00
      horsePick = "Thunder"
      bettor    =  alice  

  -- Unhappy path with privacy 

  submitMustFail bob do
    exerciseCmd firstSlip PlaceBet with 
      betAmount = 152.00
      horsePick = "Thunder"
      bettor    = alice   

  pure()

  
  





